<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>√áamakoƒülu S√ºlalesi</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="css/familienbaum.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
    <style>
        /* Modern Modal Styles */
        #crop-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.85);
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        #crop-modal-content {
            background-color: white;
            margin: auto;
            padding: 32px;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            width: 90%;
            max-width: 700px;
            max-height: 90%;
            display: flex;
            flex-direction: column;
        }

        #crop-image-container {
            max-height: 60vh;
            overflow: hidden;
            margin-bottom: 24px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        #crop-image-container img {
            max-width: 100%;
            border-radius: 8px;
        }

        .crop-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .crop-actions button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #btn-cancel-crop {
            background: #e2e8f0;
            color: #2d3748;
        }

        #btn-cancel-crop:hover {
            background: #cbd5e0;
        }

        #btn-confirm-crop {
            background: #52a788;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #btn-confirm-crop:hover {
            background: #45916f;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>

<body>
    <!-- Global Patrilineal Toggle Button -->
    <div style="position: fixed; top: 20px; right: 20px; z-index: 1000;">
        <button id="patrilineal-global-toggle" style="
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 24px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.5)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'">
            <span id="toggle-icon">üë®‚Äçüë¶</span>
            <span id="toggle-text">Sadece Erkek Soyu</span>
        </button>
    </div>

    <!-- Tree Container (SVG goes here) -->
    <div id="tree-container" style="width:100%; height:100vh;"></div>

    <!-- STATIC SIDEBAR STRUCTURE -->
    <aside id="family-sidebar">
        <div class="sidebar-header">
            <h2 id="sidebar-title">Ki≈üi Adƒ±</h2>
            <button class="close-btn" onclick="closeSidebar()">‚úï</button>
        </div>

        <div class="sidebar-content">
            <!-- Profile Image -->
            <div class="sidebar-section photo-section" style="text-align: center;">
                <div style="position: relative; display: inline-block;">
                    <img id="sidebar-image" src="" alt="Fotoƒüraf"
                        style="max-width: 100%; max-height: 220px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; cursor: pointer; transition: all 0.3s ease;">
                    <button id="delete-photo-btn"
                        style="display: none; position: absolute; top: 8px; right: 8px; background: #c84b4b; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 20px; font-weight: bold; line-height: 1; padding: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s ease;">√ó</button>
                </div>
                <div id="upload-status"
                    style="font-size: 0.95rem; color: #718096; margin-top: 12px; min-height: 1.2em; font-weight: 500;">
                </div>
                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
            </div>

            <!-- Dynamic Details -->
            <div class="sidebar-section">
                <div id="sidebar-details"></div>
            </div>

            <!-- Action Buttons -->
            <div class="sidebar-section">
                <button id="btn-parents" class="action-btn btn-primary">Atalarƒ± G√∂ster (Anne/Baba)</button>
                <button id="btn-children" class="action-btn btn-primary">Torunlarƒ± G√∂ster (√áocuklar)</button>
            </div>


            <!-- Meta -->
            <div class="sidebar-section">
                <button id="btn-open-sheet" class="action-btn btn-secondary" onclick="openSheet()">Google Tablosunu
                    A√ß</button>
            </div>
        </div>
    </aside>

    <!-- CROP MODAL -->
    <div id="crop-modal">
        <div id="crop-modal-content">
            <h3>Fotoƒürafƒ± Kƒ±rp</h3>
            <div id="crop-image-container">
                <img id="image-to-crop" src="">
            </div>
            <div class="crop-actions">
                <button id="btn-cancel-crop" class="action-btn btn-secondary">ƒ∞ptal</button>
                <button id="btn-confirm-crop" class="action-btn btn-success">‚úÇÔ∏è Kƒ±rp ve Y√ºkle</button>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="js/d3.v7.min.js"></script>
    <script src="js/dag.js"></script>
    <script src="js/dag_layout.js"></script>
    <script src="js/dag_with_relations.js"></script>
    <script src="js/dag_with_family_data.js"></script>
    <script src="js/dag_relaxation.js"></script>
    <script src="js/familienbaum.js"></script>
    <script src="js/editor.js"></script>
    <script src="js/sheet_loader.js"></script>

    <!-- Minimal Logic for Sidebar Interaction -->
    <script>
        // Global UI Functions
        function closeSidebar() {
            document.getElementById('family-sidebar').classList.remove('active');
        }

        function openDriveFolder() {
            window.open("https://drive.google.com/drive/folders/1DzFjTHjzsnM1dcJMF4jZU5RDliCzX0xH?usp=drive_link", "_blank");
        }

        function openSheet() {
            window.open("https://docs.google.com/spreadsheets/d/12kZlANYbq0w3k8TpDxssVSlWVfbs-qZQ9bAjERci0SM/edit?gid=790197592", "_blank");
        }

        // Initialize D3 in specific container
        const svg = d3.select("#tree-container").append("svg").
            attr("width", document.body.offsetWidth).
            attr("height", document.documentElement.clientHeight);

        // Restore Resize Listener
        window.addEventListener("resize", () => {
            svg.attr("width", document.body.offsetWidth)
                .attr("height", document.documentElement.clientHeight);
        });

        const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTzo66Bb8-z3QdqtNGZ9uhQJZJxePifl6nJwvtlot-3JtKp4YKYQdqJNFDY89lqHoMRdlKZmjWzh2OA/pub?output=csv";

        async function initApp() {
            let inputData = null;
            try {
                inputData = await loadFromGoogleSheet(SHEET_URL);
                localStorage.setItem('soyagaci_cached_data', JSON.stringify(inputData));
            } catch (e) {
                console.warn("Network failed, trying cache...", e);
                const cached = localStorage.getItem('soyagaci_cached_data');
                if (cached) inputData = JSON.parse(cached);
            }

            if (!inputData) {
                alert("Could not load data.");
                return;
            }

            // Restore state
            const lastNodeId = localStorage.getItem('soyagaci_last_node');
            if (lastNodeId && inputData.members[lastNodeId]) {
                inputData.start = lastNodeId;
            }

            // Expose data globally for editor
            window.familyData = inputData;
            window.fullFamilyData = JSON.parse(JSON.stringify(inputData)); // Keep full copy

            // Global Patrilineal Toggle
            let patrilinealMode = localStorage.getItem('soyagaci_patrilineal_mode') === 'true';
            const globalToggle = document.getElementById('patrilineal-global-toggle');
            const toggleIcon = document.getElementById('toggle-icon');
            const toggleText = document.getElementById('toggle-text');

            // Apply initial filter if needed
            if (patrilinealMode) {
                window.familyData = filterPatrilineal(window.fullFamilyData);
                if (globalToggle) {
                    globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                    toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                    toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';
                }
            }

            // We no longer pass 'detailsDiv' to constructor because we manage it globally now
            let familienbaum = new Familienbaum(window.familyData, svg);

            // Restore visible nodes
            const savedVisibleNodesJson = localStorage.getItem('soyagaci_visible_nodes');
            if (savedVisibleNodesJson) {
                try {
                    const savedVisibleNodes = new Set(JSON.parse(savedVisibleNodesJson));
                    if (familienbaum.dag_all) {
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (savedVisibleNodes.has(node.data)) {
                                node.added_data.is_visible = true;
                            }
                        }
                    }
                } catch (e) { console.warn("Failed to restore visible nodes", e); }
            }

            familienbaum.draw(false); // Draw without auto-centering initially

            // Restore zoom/pan
            const savedTransformJson = localStorage.getItem('soyagaci_view_transform');
            if (savedTransformJson) {
                try {
                    const t = JSON.parse(savedTransformJson);
                    const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);
                    svg.call(familienbaum.zoom.transform, transform);
                } catch (e) { console.warn("Failed to restore transform", e); }
            } else {
                // If no saved transform, do the initial center
                // We need to find the current node to center on
                let current_node = familienbaum.dag.find_node(window.familyData.start);
                if (current_node) {
                    svg.transition().duration(0).call(
                        familienbaum.zoom.transform,
                        d3.zoomTransform(familienbaum.g.node())
                            .translate(current_node.added_data.y0 - current_node.y,
                                current_node.added_data.x0 - current_node.x),
                    );
                }
            }

            // Save state function
            function saveState() {
                localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                if (familienbaum && familienbaum.g) {
                    const transform = d3.zoomTransform(familienbaum.g.node());
                    localStorage.setItem('soyagaci_view_transform', JSON.stringify({ k: transform.k, x: transform.x, y: transform.y }));

                    if (familienbaum.dag_all) {
                        const visibleNodes = [];
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (node.added_data && node.added_data.is_visible) {
                                visibleNodes.push(node.data);
                            }
                        }
                        localStorage.setItem('soyagaci_visible_nodes', JSON.stringify(visibleNodes));
                    }
                }
            }

            // Save on unload
            window.addEventListener("beforeunload", saveState);

            if (globalToggle) {
                globalToggle.addEventListener('click', () => {
                    // Save state before toggling (to capture current view)
                    // Actually, we want to capture the view *before* the toggle changes it, 
                    // but the user might want to return to this view. 
                    // However, the toggle logic below handles the immediate transition.
                    // The saveState is mainly for reload. 
                    // But we should update the patrilinealMode variable.

                    // CAPTURE STATE for immediate transition
                    let savedTransform = d3.zoomIdentity;
                    let savedVisibleNodes = new Set();

                    if (familienbaum && familienbaum.g) {
                        savedTransform = d3.zoomTransform(familienbaum.g.node());
                        if (familienbaum.dag_all) {
                            for (let node of familienbaum.dag_all.nodes()) {
                                if (node.added_data && node.added_data.is_visible) {
                                    savedVisibleNodes.add(node.data);
                                }
                            }
                        }
                    }

                    patrilinealMode = !patrilinealMode;
                    // Save the new mode immediately so it persists if they reload right after
                    localStorage.setItem('soyagaci_patrilineal_mode', patrilinealMode);

                    // Clear SVG before redrawing to prevent overlapping
                    svg.selectAll("*").remove();

                    if (patrilinealMode) {
                        // Enable patrilineal mode
                        globalToggle.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶‚Äçüë¶';
                        toggleText.textContent = 'T√ºm Soy Aƒüacƒ±';

                        const filteredData = filterPatrilineal(window.fullFamilyData);
                        window.familyData = filteredData;
                        familienbaum = new Familienbaum(filteredData, svg);
                    } else {
                        // Disable patrilineal mode - show all
                        globalToggle.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        toggleIcon.textContent = 'üë®‚Äçüë¶';
                        toggleText.textContent = 'Sadece Erkek Soyu';

                        window.familyData = JSON.parse(JSON.stringify(window.fullFamilyData));
                        familienbaum = new Familienbaum(window.familyData, svg);
                    }

                    // RESTORE STATE
                    if (familienbaum && familienbaum.dag_all) {
                        for (let node of familienbaum.dag_all.nodes()) {
                            if (savedVisibleNodes.has(node.data)) {
                                node.added_data.is_visible = true;
                            }
                        }
                    }

                    // Draw without recentering to preserve position
                    familienbaum.draw(false);

                    // Apply saved transform
                    if (familienbaum.zoom) {
                        svg.call(familienbaum.zoom.transform, savedTransform);
                    }

                    // Save state after toggle to persist the new view
                    saveState();
                });
            }
        }

        // Filter data to show only patrilineal descendants
        function filterPatrilineal(data) {
            console.log("Starting patrilineal filter, total members:", Object.keys(data.members).length);
            console.log("Displayed root:", data.start, data.members[data.start]?.name);

            const filtered = {
                start: null, // Will be set after determining lineage
                members: {},
                links: []
            };

            // Build parent-child relationships
            const unionToParents = {};
            const childToUnion = {};

            for (const link of data.links) {
                const [from, to] = link;
                if (from.startsWith('u_')) {
                    childToUnion[to] = from;
                } else if (to.startsWith('u_')) {
                    if (!unionToParents[to]) unionToParents[to] = [];
                    unionToParents[to].push(from);
                }
            }

            // Track which members are in the male lineage (Strictly Father -> Son)
            const maleLineage = new Set();
            const processed = new Set();

            // Find the actual tree root (lowest generation number)
            let actualRoot = data.start;
            let lowestGen = Infinity;
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (!member.is_spouse && member.gen < lowestGen) {
                    lowestGen = member.gen;
                    actualRoot = memberId;
                }
            }
            console.log("Actual tree root:", actualRoot, data.members[actualRoot]?.name, "gen:", lowestGen);

            // Helper to get blood parent (non-spouse parent)
            function getBloodParent(memberId) {
                const parentUnion = childToUnion[memberId];
                if (!parentUnion) return null;

                const parents = unionToParents[parentUnion] || [];
                for (const parentId of parents) {
                    const parent = data.members[parentId];
                    if (parent && !parent.is_spouse) {
                        return parentId;
                    }
                }
                return null;
            }

            // Recursively check if someone is in male lineage
            function isInMaleLineage(memberId) {
                if (processed.has(memberId)) {
                    return maleLineage.has(memberId);
                }
                processed.add(memberId);

                const member = data.members[memberId];
                if (!member) {
                    return false;
                }

                // Actual tree root is always in lineage
                if (memberId === actualRoot) {
                    maleLineage.add(memberId);
                    return true;
                }

                // Spouses are not in lineage (they'll be added separately)
                if (member.is_spouse) {
                    return false;
                }

                // Check if descended from male lineage
                const bloodParentId = getBloodParent(memberId);
                if (!bloodParentId) {
                    return false; // No parent, not in lineage
                }

                const bloodParent = data.members[bloodParentId];

                // Must be male AND parent must be male AND parent must be in male lineage
                if (member.gender === 'E' && bloodParent.gender === 'E' && isInMaleLineage(bloodParentId)) {
                    maleLineage.add(memberId);
                    return true;
                }

                return false;
            }

            // First pass: identify all male lineage members
            for (const memberId in data.members) {
                isInMaleLineage(memberId);
            }

            console.log("Male lineage members:", maleLineage.size);

            // If the displayed root is not in male lineage, switch to actual root
            const displayRoot = maleLineage.has(data.start) ? data.start : actualRoot;
            console.log("Using display root:", displayRoot, data.members[displayRoot]?.name);

            // Second pass: Identify who to DISPLAY
            // Rule:
            // 1. Members in Male Lineage
            // 2. Children of Members in Male Lineage (includes daughters)
            // 3. Spouses of anyone in 1 or 2

            const displayedMembers = new Set();

            for (const memberId in data.members) {
                const member = data.members[memberId];

                if (maleLineage.has(memberId)) {
                    displayedMembers.add(memberId);
                } else if (!member.is_spouse) {
                    // Check if parent is in male lineage
                    const bloodParentId = getBloodParent(memberId);
                    if (bloodParentId && maleLineage.has(bloodParentId)) {
                        displayedMembers.add(memberId);
                    }
                }
            }

            // Add spouses of displayed members
            for (const memberId in data.members) {
                const member = data.members[memberId];
                if (member.is_spouse) {
                    // Check if partner is displayed
                    const parentUnion = childToUnion[memberId];
                    if (parentUnion) {
                        const parents = unionToParents[parentUnion] || [];
                        for (const parentId of parents) {
                            if (displayedMembers.has(parentId)) {
                                displayedMembers.add(memberId);
                                break;
                            }
                        }
                    } else {
                        // Spouse without parent union - check unions they're part of
                        for (const link of data.links) {
                            const [from, to] = link;
                            if (from === memberId && to.startsWith('u_')) {
                                // This spouse is in a union
                                const partners = unionToParents[to] || [];
                                for (const partnerId of partners) {
                                    if (partnerId !== memberId && displayedMembers.has(partnerId)) {
                                        displayedMembers.add(memberId);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Populate filtered members
            for (const memberId of displayedMembers) {
                filtered.members[memberId] = data.members[memberId];
            }

            // Filter links
            for (const link of data.links) {
                const [from, to] = link;

                if (to.startsWith('u_') || from.startsWith('u_')) {
                    // Union link - include if at least one end is included
                    const fromIncluded = from.startsWith('u_') || filtered.members[from];
                    const toIncluded = to.startsWith('u_') || filtered.members[to];

                    if (fromIncluded && toIncluded) {
                        filtered.links.push(link);
                    }
                } else {
                    // Direct link
                    if (filtered.members[from] && filtered.members[to]) {
                        filtered.links.push(link);
                    }
                }
            }

            console.log("Filtered members count:", Object.keys(filtered.members).length);
            console.log("Filtered links count:", filtered.links.length);

            // SAFEGUARD: Ensure display root is in members
            if (!filtered.members[displayRoot]) {
                console.warn("Display root", displayRoot, "was missing from filtered members! Adding it forcibly.");
                filtered.members[displayRoot] = data.members[displayRoot];
            }

            // DEBUG: Check if display root is in any link
            const rootInLinks = filtered.links.some(link => link[0] === displayRoot || link[1] === displayRoot);
            if (!rootInLinks) {
                console.warn("Display root", displayRoot, "is NOT in any filtered link! This will cause 'Node not found' error.");
                // Attempt to find at least one link for the root
                const rootLinks = data.links.filter(link => link[0] === displayRoot || link[1] === displayRoot);
                console.log("Original links for root:", rootLinks);
            }

            filtered.start = displayRoot;
            return filtered;
        }

        // Shift Key Listeners
        document.addEventListener('keydown', (e) => { if (e.key === 'Shift') document.body.classList.add('show-plus'); });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift') document.body.classList.remove('show-plus'); });

        initApp();
    </script>
</body>

</html>